<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\HttpFoundation\Ipv6;

/**
 * Normalizer for IPv6 addresses.
 *
 * Code taken from phpBB 3.0.
 *
 * @author Igor Wiedler <igor@wiedler.ch>
 * @author Andreas Fischer <bantu@phpbb.com>
 * @author Marek A. Ruszczy≈Ñski <aptx@phpbb.com>
 * @author Nils Adermann <naderman@naderman.de>
 */
class Normalizer
{
    // Regular expressions generated by: https://github.com/phpbb/phpbb3/blob/develop-olympus/phpBB/develop/regex.php
    const IPV4_REGEX = '#^(?:(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$#';
    const IPV6_REGEX = '#^(?:(?:(?:[\dA-F]{1,4}:){6}(?:[\dA-F]{1,4}:[\dA-F]{1,4}|(?:(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])))|(?:::(?:[\dA-F]{1,4}:){0,5}(?:[\dA-F]{1,4}(?::[\dA-F]{1,4})?|(?:(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])))|(?:(?:[\dA-F]{1,4}:):(?:[\dA-F]{1,4}:){4}(?:[\dA-F]{1,4}:[\dA-F]{1,4}|(?:(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])))|(?:(?:[\dA-F]{1,4}:){1,2}:(?:[\dA-F]{1,4}:){3}(?:[\dA-F]{1,4}:[\dA-F]{1,4}|(?:(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])))|(?:(?:[\dA-F]{1,4}:){1,3}:(?:[\dA-F]{1,4}:){2}(?:[\dA-F]{1,4}:[\dA-F]{1,4}|(?:(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])))|(?:(?:[\dA-F]{1,4}:){1,4}:(?:[\dA-F]{1,4}:)(?:[\dA-F]{1,4}:[\dA-F]{1,4}|(?:(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])))|(?:(?:[\dA-F]{1,4}:){1,5}:(?:[\dA-F]{1,4}:[\dA-F]{1,4}|(?:(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])))|(?:(?:[\dA-F]{1,4}:){1,6}:[\dA-F]{1,4})|(?:(?:[\dA-F]{1,4}:){1,7}:)|(?:::))$#i';

    /**
     * Normalises an internet protocol address,
     * also checks whether the specified address is valid.
     *
     * IPv4 addresses are returned 'as is'.
     *
     * IPv6 addresses are normalised according to
     *  A Recommendation for IPv6 Address Text Representation
     *  http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-07
     *
     * @param string $address Input IP address
     *
     * return string|Boolean    false if specified address is not valid,
     *                          string otherwise
     */
    public function normalize($address)
    {
        return $this->inetNtop($this->inetPton($address));
    }

    /**
     * Converts a packed internet address to a human readable representation.
     *
     * @param string $inAddr    A 32bit IPv4, or 128bit IPv6 address.
     *
     * @return string|Boolean   false on failure,
     *                          string otherwise
     */
    public function inetNtop($inAddr)
    {
        $inAddr = bin2hex($inAddr);

        switch (strlen($inAddr)) {
            case 8:
                return implode('.', array_map('hexdec', str_split($inAddr, 2)));

            case 32:
                if (substr($inAddr, 0, 24) === '00000000000000000000ffff') {
                    return $this->inetNtop(pack('H*', substr($inAddr, 24)));
                }

                $parts = str_split($inAddr, 4);
                $parts = preg_replace('/^0+(?!$)/', '', $parts);
                $ret = implode(':', $parts);

                $matches = array();
                preg_match_all('/(?<=:|^)(?::?0){2,}/', $ret, $matches, PREG_OFFSET_CAPTURE);
                $matches = $matches[0];

                if (empty($matches)) {
                    return $ret;
                }

                $longestMatch = '';
                $longestMatchOffset = 0;
                foreach ($matches as $match) {
                    if (strlen($match[0]) > strlen($longestMatch)) {
                        $longestMatch = $match[0];
                        $longestMatchOffset = $match[1];
                    }
                }

                $ret = substr_replace($ret, '', $longestMatchOffset, strlen($longestMatch));

                if ($longestMatchOffset == strlen($ret)) {
                    $ret .= ':';
                }

                if ($longestMatchOffset == 0) {
                    $ret = ':' . $ret;
                }

                return $ret;

            default:
                return false;
        }
    }

    /**
     * Converts a human readable IP address to its packed in_addr representation.
     *
     * @param string $address   A human readable IPv4 or IPv6 address.
     *
     * @return mixed        false if address is invalid,
     *                      in_addr representation of the given address otherwise (string)
     */
    public function inetPton($address)
    {
        $ret = '';
        if (preg_match(self::IPV4_REGEX, $address)) {
            foreach (explode('.', $address) as $part) {
                $ret .= ($part <= 0xF ? '0' : '') . dechex($part);
            }

            return pack('H*', $ret);
        }

        if (preg_match(self::IPV6_REGEX, $address)) {
            $parts = explode(':', $address);
            $missingParts = 8 - sizeof($parts) + 1;

            if (substr($address, 0, 2) === '::') {
                ++$missingParts;
            }

            if (substr($address, -2) === '::') {
                ++$missingParts;
            }

            $embeddedIpv4 = false;
            $lastPart = end($parts);

            if (preg_match(self::IPV4_REGEX, $lastPart)) {
                $parts[sizeof($parts) - 1] = '';
                $lastPart = $this->inetPton($lastPart);
                $embeddedIpv4 = true;
                --$missingParts;
            }

            foreach ($parts as $i => $part) {
                if (strlen($part)) {
                    $ret .= str_pad($part, 4, '0', STR_PAD_LEFT);
                } else if ($i && $i < sizeof($parts) - 1) {
                    $ret .= str_repeat('0000', $missingParts);
                }
            }

            $ret = pack('H*', $ret);

            if ($embeddedIpv4) {
                $ret .= $lastPart;
            }

            return $ret;
        }

        return false;
    }
}
